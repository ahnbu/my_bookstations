13c2f89
ahnbu
Mon Nov 10 13:18:14 2025 +0900
refactor(UX): 재고 정보 표시 UX 개선 및 안정성 강화
사용자 경험(UX)을 개선하기 위해 내 서재의 도서관 재고 정보 표시 방식을 리팩토링했습니다. 이번 변경의 핵심 목표는 API의 일시적인 실패가 사용자에게 불필요한 스트레스를 주지 않도록 하고, 정보의 성격에 따라 표시 방식을 달리하는 것입니다.

### 주요 변경 사항

1.  **목록 뷰(내 서재)의 안정성 강화:**
    -   `MyLibraryListItem`의 재고 태그(`LibraryTag`)는 이제 API 갱신 실패 여부(`isError`)를 색상에 반영하지 않습니다.
    -   오직 DB에 저장된 마지막 성공 데이터(`stock_*` 컬럼)만을 기준으로 색상을 표시하여, API가 일시적으로 실패하더라도 목록에서는 항상 안정적인 정보(녹색/회색)가 보이도록 수정했습니다.

2.  **상세 뷰(상세 모달)의 정확성 유지:**
    -   `MyLibraryBookDetailModal`의 재고 표시(`StockDisplay`) 로직은 그대로 유지하여, 상세 정보 확인 시에는 API 갱신 실패 상태를 명확하게 인지할 수 있도록 했습니다. (빨간색 및 `(에러)` 텍스트 표시)

3.  **신규 도서 추가 시 UX 개선:**
    -   새 책을 서재에 추가할 때, 재고 정보가 조회되기 전까지의 초기 상태가 '에러'(빨간색)로 잠시 표시되던 문제를 해결했습니다.
    -   이제는 '정보 없음'(회색)으로 표시되다가 API 응답 후 상태가 변경되어, 훨씬 더 자연스럽고 안정적인 사용자 경험을 제공합니다.

이번 리팩토링은 "점진적 정보 공개(Progressive Disclosure)" 원칙에 따라, 목록에서는 간결하고 안정적인 정보를, 상세 뷰에서는 정확하고 상세한 상태 정보를 제공하도록 역할을 명확히 분리했습니다.


bfbcb59
ahnbu
Mon Nov 10 12:42:20 2025 +0900
refactor(Core): 스키마 버전 관리 시스템 제거 및 코드 단순화
기존에 도입했던 `schemaVersion` 기반의 동적 데이터 마이그레이션 시스템을 폐기하고, 개발자가 직접 SQL로 마이그레이션을 관리하는 표준 방식으로 아키텍처를 변경함에 따라 관련 코드를 모두 정리했습니다.

이 변경은 데이터베이스의 일관성을 완벽하게 보장하고, 애플리케이션 코드의 복잡성을 크게 낮추기 위함입니다.

### 주요 변경 사항

1.  **`useAppStore` 및 관련 로직 제거:**
    -   DB에서 스키마 버전을 동적으로 가져오던 `useAppStore`를 완전히 삭제했습니다.
    -   `App.tsx`에서 앱 초기화 시 스키마 버전을 불러오던 로직과 로딩 화면을 제거하여 앱 시작 절차를 단순화했습니다.

2.  **`schemaVersion` 속성 제거:**
    -   `types.ts`의 `BookData` 타입 정의와 `useBookStore`의 관련 로직에서 `schemaVersion` 속성을 모두 제거했습니다.
    -   DB의 `user_library` 테이블에 있는 `book_data` JSON 필드에서도 `schemaVersion` 키를 제거하는 일회성 SQL 마이그레이션을 수행했습니다.

3.  **캐시 우회 로직 단순화:**
    -   `refreshBookInfo` 함수에서 `schemaVersion`을 비교하여 캐시 우회 여부(`isDbSchemaChanged`)를 결정하던 로직을 제거했습니다.
    -   이제 캐시 갱신은 Cloudflare의 TTL(12시간) 정책을 따르거나, 필요한 경우 수동으로 캐시를 무효화하는 방식으로 관리됩니다.

이번 코드 정리를 통해 애플리케이션은 더 이상 여러 버전의 데이터 스키마를 고려할 필요가 없어졌으며, 데이터 마이그레이션에 대한 책임 소재를 명확히 하여 장기적인 유지보수성을 향상시켰습니다.


8bdb854
ahnbu
Mon Nov 10 12:02:52 2025 +0900
프로젝트의 핵심 데이터인 도서관 재고 정보의 안정성과 일관성을 확보하고, 향후 확장성을 개선하기 위해 데이터베이스 스키마와 관련 로직을 전면적으로 리팩토링했습니다.
이번 리팩토링의 핵심 목표는 크롤링 API의 간헐적 실패에도 데이터가 유실되지 않는 견고한 시스템을 구축하는 것입니다.

### 주요 변경 사항

#### 1. DB 스키마 변경: 재고 정보 컬럼 분리
- **`user_library` 테이블에 도서관별 재고 정보를 저장할 12개의 `stock_*` 컬럼을 신규 추가했습니다.** (`stock_gwangju_toechon_total` 등)
- 이는 변동성이 높은 API 응답 결과와 안정적으로 유지되어야 할 재고 데이터를 분리하여 관리하기 위함입니다.
- 향후 재고 기반 필터링 및 검색 성능을 위해 `_total` 컬럼들에 인덱스를 추가했습니다.

#### 2. 데이터 마이그레이션 및 정합성 확보
- 기존 `book_data` JSON에 저장되어 있던 재고 정보를 새로 추가된 `stock_*` 컬럼으로 이전하는 일회성 마이그레이션을 완료했습니다.
- 마이그레이션 전/후 데이터 검증 쿼리를 통해 JSON 내부 데이터와 신규 컬럼 데이터 간의 정합성을 100% 확인했습니다.
- `book_data.siripEbookInfo` 객체 내에 `availableCountOwned`, `availableCountSubs` 필드를 추가하여 데이터 구조의 일관성을 높였습니다.

#### 3. 프론트엔드 데이터 흐름 재설계 (`useBookStore`)
- **`refreshBookInfo` 로직 강화 (핵심 변경):**
    - **"선택적 폴백(Fallback)" 전략을 도입**하여, API 호출이 실패하더라도 기존의 유효한 `book_data`가 유실되지 않도록 데이터를 보호합니다.
    - `schemaVersion`을 이용한 런타임 마이그레이션 로직을 폐기하고, 표준적인 DB 마이그레이션 절차를 따르도록 아키텍처를 단순화했습니다.
    - 데이터 업데이트 시, `book_data` JSON과 `stock_*` 컬럼이 **동일한 API 원본으로부터 함께 업데이트**되도록 하여 데이터 불일치 위험을 원천적으로 차단했습니다.
- **데이터 조회 로직 수정:**
    - `fetchUserLibrary`, `getBookById` 등 모든 DB 조회 함수가 새로운 `stock_*` 컬럼을 함께 가져오도록 `select` 구문을 수정했습니다.
    - 반복되는 로직을 `mapDbItemToSelectedBook` 헬퍼 함수로 중앙화하여 코드 중복을 줄였습니다.

#### 4. UI 컴포넌트 수정
- `MyLibraryListItem`과 `MyLibraryBookDetailModal`의 재고 표시 컴포넌트(`LibraryTag`, `StockDisplay`)가 더 이상 복잡한 `book_data` JSON 경로를 참조하지 않고, **새롭게 추가된 최상위 `stock_*` 컬럼을 직접 참조**하도록 수정했습니다.
- 이를 통해 UI 코드의 가독성과 안정성이 크게 향상되었습니다.

#### 5. 백엔드 API (Cloudflare Worker) 수정
- `siripEbook` API 응답 객체에 `availableCountOwned`, `availableCountSubs` 필드를 추가하여, 클라이언트의 계산 부담을 줄이고 서버의 책임을 강화했습니다.

이번 리팩토링을 통해 애플리케이션은 API의 일시적인 오류에 훨씬 더 탄력적으로 대응할 수 있게 되었으며, 향후 재고 관련 기능 확장을 위한 견고한 데이터 기반을 마련했습니다.


13e9aad
ahnbu
Mon Nov 10 10:44:51 2025 +0900
fix(Store): 데이터 업데이트 시 `id`, `note` 누락 문제 해결 및 로직 안정화
### 📝 요약 (Summary)

`book_data` JSON 컬럼에 `id`와 `note`를 포함하여 저장하는 현재 DB 구조와 `useBookStore`의 데이터 업데이트 로직 간의 불일치 문제를 해결했습니다. 이로 인해 일괄 갱신 시 `id`, `note`가 누락되거나, 개별 갱신 시 데이터가 손상되던 문제를 모두 수정하여 데이터 일관성을 확보했습니다.

### 🧐 문제 상황 (Problem)

1.  **잘못된 가정:** `updateBookInStoreAndDB` 함수는 `id`와 `note`가 `book_data` 외부에 있는 별도 컬럼이라는 잘못된 가정 하에, 업데이트 시마다 `book_data`에서 이 두 필드를 **제거**하고 있었습니다.
2.  **일괄 갱신 시 데이터 누락:** 스키마가 다른 오래된 데이터를 일괄 갱신할 때, "전체 덮어쓰기" 로직이 `originalBook`의 `id`와 `note`를 참조하지 않아, 최종적으로 `book_data`에서 `id`, `note`가 누락된 채로 DB에 저장되었습니다.
3.  **개별 갱신 시 데이터 손상:** 개별 갱신 역시 `id`, `note`를 제거하는 로직을 수행하여 DB 데이터를 손상시키고 있었습니다. 이는 낙관적 UI 업데이트 때문에 즉시 드러나지 않았을 뿐, 근본적으로 동일한 문제였습니다.

### ✨ 해결 방안 (Solution)

1.  **`updateBookInStoreAndDB` 로직 수정:**
    -   `book_data`에서 `id`와 `note`를 제거하는 코드를 삭제했습니다.
    -   이제 `book_data` 컬럼에는 항상 `id`와 `note`가 포함된 완전한 `SelectedBook` 객체의 복사본이 저장됩니다.
    -   어떤 업데이트든 최상위 `note` 컬럼도 항상 함께 동기화하도록 로직을 보강했습니다.

2.  **`refreshBookInfo` 로직 강화:**
    -   "전체 덮어쓰기(마이그레이션)" 로직이 실행될 때, 함수 파라미터로 받은 `id`와 `originalBook`의 `note`를 최종 데이터 객체(`updatedBookForUI`)에 명시적으로 다시 조합하도록 수정했습니다.
    -   이를 통해 `originalBook`의 상태와 관계없이, DB에 저장되는 데이터의 무결성을 보장합니다.
    -   DB 업데이트 실패 시 `catch` 블록으로 에러를 전파하여 UI 롤백이 정상적으로 실행되도록 `if (error) throw error;` 구문을 복원했습니다.

### 🎯 기대 효과 (Expected Benefits)

-   **데이터 일관성 확보:** 이제 개별/일괄 갱신, 태그 수정 등 모든 업데이트 작업에서 `book_data`는 항상 `id`와 `note`를 포함한 완전한 스키마를 유지합니다.
-   **버그 해결:** 일괄 갱신 시 `id`, `note`가 누락되던 문제와, 개별 갱신 시 DB 데이터가 손상되던 문제가 모두 해결되었습니다.
-   **안정성 향상:** DB 업데이트 실패 시 롤백 로직이 안정적으로 동작하여 UI와 DB 간의 데이터 불일치 가능성을 차단했습니다.


3325dff
ahnbu
Sun Nov 9 17:32:39 2025 +0900
feat(Core): DB 부분 업데이트 기능과 DB 구조 변경시 대응로직 개선
## 핵심

- DB 구조나 변수명이 변경되면, 에러 여부 상관없이 DB와 캐싱 업데이트
- (DB구조가 동일한 것을 체크한 후에) API응답이 일부만 변경되면, 해당 부분만 업데이트

## feat(Core): DB 스키마 버전을 이용한 자동화된 데이터 마이그레이션 시스템 구축

### 📝 요약 (Summary)

데이터 스키마 변경에 안전하고 유연하게 대응하기 위해, DB에 저장된 개별 데이터의 스키마 버전과 현재 코드의 스키마 버전을 비교하는 시스템을 도입했습니다. 이를 통해 과거 스키마의 데이터는 자동으로 최신 스키마로 마이그레이션되며, 이 과정에서 백엔드 캐시가 지능적으로 관리됩니다.

### ✨ 주요 변경 사항 (Key Changes)

1.  **DB 스키마 버전 필드 추가:**
    -   프론트엔드 `types.tsx`의 `BookData` 타입에 `schemaVersion` 속성을 추가하여 데이터 구조의 버전을 기록할 수 있는 기반을 마련했습니다.

2.  **스키마 비교에 따른 DB 업데이트 및 캐시 전략 분기:**
    -   책 정보 새로고침(`refreshBookInfo`) 시, DB에 저장된 `schemaVersion`과 코드의 현재 버전을 비교합니다.
    -   **[스키마 불일치 시]**: 데이터 마이그레이션을 위해 백엔드에 캐시를 우회하도록 요청(`isDbSchemaChanged: true`)하고, API로부터 받은 최신 데이터를 기반으로 DB 레코드를 **안전하게 전체 덮어쓰기**합니다.
    -   **[스키마 일치 시]**: 효율성을 위해 백엔드 캐시를 사용하고, API 응답에 부분적인 실패가 있더라도 성공한 데이터는 유지하는 **지능형 부분 업데이트**를 수행합니다.

3.  **DB 기반 동적 버전 관리 도입 (자동화):**
    -   기존의 하드코딩된 버전 상수를 제거하고, Supabase `app_metadata` 테이블에서 최신 스키마 버전을 동적으로 가져오도록 시스템을 고도화했습니다.
    -   앱 시작 시 최신 버전을 로드하는 `useAppStore`를 신설하고, 모든 로직이 이 중앙화된 버전 정보를 참조하도록 수정했습니다.

4.  **신규 데이터 버전 기록:**
    -   새 책을 서재에 추가할 때(`addToLibrary`), DB에서 가져온 최신의 `schemaVersion`을 자동으로 기록하도록 수정했습니다. 이를 통해 신규 데이터가 구버전으로 잘못 인식되는 문제를 해결했습니다.

### 🎯 기대 효과 (Expected Benefits)

-   **안전한 데이터 마이그레이션:** `isAvailable` -> `loanStatus`와 같은 스키마 변경이 발생하더라도, 사용자의 데이터는 다음번 새로고침 시 자동으로, 그리고 데이터 손실 없이 최신 구조로 업데이트됩니다.
-   **지능적인 캐시 관리:** 오래된 스키마의 캐시 데이터가 최신 코드와 충돌하는 문제를 원천적으로 차단하고, 스키마 마이그레이션이 필요한 경우에만 캐시를 자동으로 갱신합니다.
-   **향상된 유지보수성:** 향후 스키마 변경 시, 개발자는 DB의 버전 숫자만 수정하면 되므로, 복잡한 마이그레이션 스크립트 없이도 시스템 전체가 변화에 자동으로 대응할 수 있습니다.

## feat(Core): DB 기반의 동적 스키마 버전 관리 시스템 도입

### 📝 요약 (Summary)

기존에 프론트엔드 코드에 하드코딩 되어 있던 데이터 스키마 버전을 Supabase DB에서 동적으로 가져와 관리하는 시스템을 구축했습니다. 이를 통해 향후 데이터 구조 변경 시 코드 재배포 없이 안정적인 데이터 마이그레이션과 캐시 관리가 가능해졌습니다.

### ✨ 주요 변경 사항 (Key Changes)

1.  **DB 기반 버전 관리 도입:**
    -   `app_metadata` 테이블을 Supabase에 신설하여 `book_data`의 현재 스키마 버전을 중앙에서 관리합니다.
    -   모든 사용자가 읽을 수 있도록 RLS 정책을 설정했습니다.

2.  **전역 상태 관리 스토어 신설 (`useAppStore`):**
    -   앱 시작 시 DB에서 최신 스키마 버전을 가져와 전역 상태로 관리하는 `useAppStore`를 구현했습니다.
    -   `App.tsx`에 초기화 로직(`initializeApp`)을 추가하여, 앱 로드 시 스키마 버전을 우선적으로 불러오도록 수정했습니다.

3.  **캐시 우회 및 마이그레이션 로직 자동화:**
    -   `useBookStore`의 `refreshBookInfo` 함수가 DB의 `schemaVersion`과 `useAppStore`의 최신 버전을 비교하도록 로직을 변경했습니다.
    -   버전 불일치 시, 백엔드(`library-checker`)에 캐시를 우회하도록 요청(`isDbSchemaChanged: true`)하여 최신 데이터를 강제로 가져옵니다.
    -   가져온 최신 데이터를 기반으로 DB 레코드를 안전하게 덮어쓰는(마이그레이션) 로직을 완성했습니다.

4.  **신규 데이터 버전 기록:**
    -   `addToLibrary` 함수를 수정하여, 새로 추가되는 책 데이터에 현재의 최신 스키마 버전을 자동으로 기록하도록 했습니다. 이로써 신규 데이터가 구버전으로 취급되는 문제를 해결했습니다.

### 🎯 기대 효과 (Expected Benefits)

-   **유지보수성 향상:** 향후 스키마 변경 시, DB의 버전 숫자만 변경하면 모든 클라이언트가 자동으로 마이그레이션 로직을 수행하므로 관리가 매우 용이해집니다.
-   **안정성 강화:** 개발자의 수동 버전 관리 실수를 원천적으로 차단하고, 오래된 캐시 데이터로 인한 데이터 오염 문제를 해결하여 시스템의 안정성을 크게 높였습니다.
-   **확장성 확보:** `app_metadata` 테이블을 통해 향후 `user_settings` 등 다른 데이터의 스키마 버전도 중앙에서 통합 관리할 수 있는 기반을 마련했습니다.


01e82f8
ahnbu
Sun Nov 9 15:42:32 2025 +0900
feat(Refactor): API 응답의 `loanStatus` 타입을 boolean으로 단일화
### 📝 요약 (Summary)

프로젝트 전반에 걸쳐 혼용되던 대출 상태(`loanStatus`)의 데이터 타입을 `boolean`으로 통일했습니다. 기존에는 `'대출가능'/'대출불가'`와 같은 문자열과 `true/false`가 혼재되어 있었으나, 이제부터 모든 API 응답과 내부 데이터 구조는 `loanStatus: boolean` 형태를 따릅니다.

### ✨ 개선 사항 (Improvements)

1.  **데이터 일관성 확보**:
    -   Cloudflare Worker(백엔드)의 모든 파싱 함수(`parseGwangjuPaperHTML`, `parseGyeonggiEduHTML` 등)가 `loanStatus`를 `boolean`으로 변환하여 반환하도록 수정했습니다.
    -   이에 맞춰 `library-checker`와 프론트엔드의 TypeScript 타입 정의(`*.types.ts`)를 모두 갱신했습니다.

2.  **코드 단순성 및 가독성 향상**:
    -   프론트엔드 컴포넌트 및 헬퍼 함수에서 `'대출가능'` 문자열과 비교하던 복잡한 로직을 제거했습니다.
    -   이제 `if (book.loanStatus)` 와 같이 직관적이고 간결한 조건문으로 대출 가능 여부를 확인할 수 있습니다.

3.  **잠재적 버그 제거**:
    -   TypeScript가 타입 불일치 오류를 컴파일 타임에 감지할 수 있게 되어 런타임 에러 발생 가능성을 원천적으로 차단했습니다. (`boolean`과 `string` 비교 오류 해결)

### 🎯 영향 범위 (Impact Scope)

-   **Backend (`library-checker`):**
    -   `src/index.tsx`: 파싱 함수 로직 수정
    -   `src/types.tsx`: 인터페이스 타입 정의 수정
-   **Frontend:**
    -   `services/unifiedLibrary.service.ts`: `loanStatus` 관련 헬퍼 함수 로직 수정
    -   `types.tsx`: `PaperBookAvailability`, `gyeonggiEduEbookList` 타입 정의 수정

이번 리팩토링을 통해 코드의 안정성과 유지보수성이 크게 향상되었습니다.


a0896c8
ahnbu
Sun Nov 9 14:52:18 2025 +0900
fix(UI): 상세 모달에서 발생하는 TypeError 수정 및 안정성 강화
### 📝 요약 (Summary)

`MyLibraryBookDetailModal` 컴포-넌트에서 시립도서관 전자책 재고(`siripEbookInfo`) 정보가 `null`일 때, 하위 속성인 `.bookList`에 접근하려다 발생하는 `TypeError: Cannot read properties of undefined (reading 'filter')` 오류를 수정했습니다.

### 🧐 원인 (Cause)

-   API 응답이 아직 없거나 실패한 경우, `book.siripEbookInfo` 객체는 `null` 또는 `undefined`가 될 수 있습니다.
-   기존 코드에서는 `book.siripEbookInfo`가 `null`인 상황을 고려하지 않고 `.bookList` 속성에 직접 접근하여 `.filter()` 메서드를 호출했기 때문에 런타임 에러가 발생했습니다.

### ✨ 해결 (Solution)

**옵셔널 체이닝(`?.`)**을 사용하여 `bookList` 속성에 안전하게 접근하도록 코드를 수정했습니다. 이를 통해 중첩된 객체의 각 단계가 유효한지 먼저 확인하고, 유효하지 않으면 즉시 `undefined`를 반환하여 에러를 방지합니다.

#### 코드 변경 사항:

-   **Before:**
    ```typescript
    // book.siripEbookInfo가 null이면 에러 발생
    availableCount={... ? book.siripEbookInfo.bookList.filter(...) : ...}
    ```

-   **After:**
    ```typescript
    // book.siripEbookInfo 또는 bookList가 null/undefined여도 안전
    availableCount={book.siripEbookInfo?.bookList?.filter(...)}
    ```

### 🎯 영향 범위 (Impact Scope)

-   `MyLibraryBookDetailModal.tsx`
-   (동일 로직이 사용된 `MyLibraryListItem.tsx`도 함께 점검 및 수정 완료)

이번 수정으로 인해, 시립도서관 재고 정보의 유무와 관계없이 도서 상세 정보 모달이 안정적으로 렌더링됩니다.


3642bb4
ahnbu
Sun Nov 9 14:26:21 2025 +0900
feat(file) : ts파일 일괄 변환 ps1 파일 추가


0a1af88
ahnbu
Sat Nov 8 18:57:00 2025 +0900
refactor(api): 시립 전자도서관(siripEbook) API 응답 구조 평탄화 & 재고 일괄 갱신 시 발생하는 'socket hang up' 에러 해결
refactor(api): 시립 전자도서관(siripEbook) API 응답 구조 평탄화

**목표:**
`siripEbookInfo`의 복잡한 중첩 구조(`details`, `summary`)를 다른 도서관 API 응답(`gyeonggiEbookInfo` 등)과 동일한 평탄한 구조로 통일하여, 프론트엔드의 데이터 처리 로직을 단순화하고 코드의 일관성과 유지보수성을 향상시킵니다.

**주요 변경 사항:**

**1. 서버 (Cloudflare Worker) 변경 사항:**
-   **`types.ts`:**
    -   `SiripEbookDetails` 타입을 제거했습니다.
    -   `SiripEbookResult` 타입을 요약 정보와 단일 `bookList`를 포함하는 평탄한 구조로 재설계했습니다.
    -   `SiripEbookBook` 유니온 타입을 추가하여 소장형과 구독형을 함께 다룰 수 있도록 했습니다.
-   **`index.ts` (`searchSiripEbookIntegrated` 함수):**
    -   소장형(`owned`)과 구독형(`subscription`) API 결과를 조합하여, 단일 `bookList`를 가진 평탄화된 `SiripEbookResult` 객체를 생성하도록 로직을 변경했습니다.
    -   모든 에러 정보는 최상위 `errors` 객체에 일관되게 담도록 수정했습니다.

**2. 클라이언트 (React App) 변경 사항:**
-   **`MyLibraryListItem.tsx` (`LibraryTagsGroup`):**
    -   `e시립구독`, `e시립소장` 태그가 평탄화된 데이터 구조에 접근하도록 경로를 수정했습니다.
    -   (예: `book.siripEbookInfo.details.owned.totalCount` -> `book.siripEbookInfo.totalCountOwned`)
-   **`MyLibraryBookDetailModal.tsx` (`StockDisplay`):**
    -   `LibraryTagsGroup`과 마찬가지로, `e시립구독`, `e시립소장` 재고 정보가 새로운 데이터 구조를 참조하도록 수정했습니다.
    -   `availableCount`는 통합된 `bookList`를 직접 필터링하여 계산하도록 로직을 개선했습니다.

이번 리팩토링을 통해 `siripEbookInfo` 관련 처리 로직이 크게 단순화되었으며, 모든 도서관 데이터를 일관된 방식으로 다룰 수 있는 기반이 마련되었습니다.

fix(core): 재고 일괄 갱신 시 발생하는 'socket hang up' 에러 해결

**문제점:**
'재고 일괄 갱신' 기능 실행 시, 짧은 시간 안에 외부 API(알라딘)로 너무 많은 요청이 동시에 전송되어 서버의 Rate Limiting 정책에 의해 연결이 강제 종료되는 `socket hang up` 에러가 간헐적으로 발생했습니다. 기존 로직은 배치(batch) 단위로만 지연(delay)을 적용하여, 개별 요청들은 여전히 한꺼번에 전송되는 문제가 있었습니다.

**해결책:**

1.  **개별 요청 사이 지연 로직 추가 (`useBookStore.tsx`):**
    -   `bulkRefreshAllBooks` 함수 내의 `setTimeout` 로직의 위치를 **배치(batch) 사이에서 개별 책(book) 요청 사이로 이동**시켰습니다.
    -   이제 각 책의 정보를 갱신한 후 200ms의 지연 시간을 두어, API 서버에 가해지는 부하를 분산시키고 안정적인 요청 흐름을 유지합니다.

2.  **일시정지 콜백 안정성 강화 (`SettingsModal.tsx`):**
    -   `bulkRefreshAllBooks` 호출 시 전달하는 `shouldPause` 콜백이 클로저(closure)로 인해 오래된 상태(stale state)를 참조하던 문제를 해결했습니다.
    -   이제 `useBookStore.getState()`를 통해 항상 최신 `isPaused` 상태를 스토어에서 직접 읽어오므로, '일시정지' 기능이 더 안정적으로 작동합니다.

이번 수정으로 재고 일괄 갱신 기능의 안정성이 크게 향상되었으며, 외부 API와의 통신 오류가 현저히 줄어들 것으로 기대됩니다.


0221ffa
ahnbu
Sat Nov 8 18:18:21 2025 +0900
fix(UI): API 에러 발생 시 표시 비일관성 문제 해결
API 호출 실패 시, '책 상세 모달'과 '내 서재 목록'에서 에러 상태가 비일관적으로 표시되거나(빨간색/회색), "조회중..." 상태로 멈추는 버그를 수정합니다.

**1. 책 상세 모달의 "조회중..." 버그 수정 (`MyLibraryBookDetailModal.tsx`)**

- **문제점:** API 응답 객체가 `null`일 경우, `StockDisplay` 컴포넌트가 이를 에러로 인지하지 못하고 "조회중..." 상태로 무한 대기하는 문제가 있었습니다.
- **해결책:** `hasError` prop을 계산할 때, 데이터 객체가 `null`이거나 `undefined`인 경우 자체를 에러 상태로 간주하도록 로직을 강화했습니다. 이를 통해 API 호출이 실패하면 "조회중..."이 아닌 명확한 (에러) 상태로 표시됩니다.

**2. 내 서재 목록의 에러 표시 통일 (`MyLibraryListItem.tsx`)**

- **문제점:** `gwangjuPaperInfo`(`퇴촌`, `기타`)의 API 에러가 발생해도 회색(정상)으로 표시되는 등, `LibraryTagsGroup` 내부의 각 `LibraryTag`가 에러를 판단하는 기준이 달라 표시가 비일관적이었습니다.
- **해결책:** 모든 `LibraryTag`의 `isError` prop을 판단하는 로직을 `!book.someInfo || ('error' in book.someInfo)` 패턴으로 표준화했습니다. 이제 어떤 도서관의 API 조회가 실패하더라도 일관되게 빨간색(에러) 상태로 표시됩니다.

이번 수정으로 모든 API 에러 시나리오에 대해 사용자에게 일관되고 명확한 피드백을 제공할 수 있게 되었습니다.


3af3765
ahnbu
Sat Nov 8 17:42:17 2025 +0900
refactor(MyLibraryListItem): LibraryTagsGroup 컴포넌트 추출 및 데이터 접근 로직 개선
`MyLibraryListItem` 컴포넌트의 가독성과 유지보수성을 향상시키고, 데이터 처리의 안정성을 높이기 위해 리팩토링을 진행했습니다.

**1. 코드 중복 제거: `LibraryTagsGroup` 컴포넌트 추출**

-   **문제점:** 카드뷰와 그리드뷰에서 도서관 재고 태그(`LibraryTag`)를 렌더링하는 코드가 완전히 중복되어 있었습니다. 이로 인해 향후 로직 수정 시 두 곳을 모두 변경해야 하는 번거로움과 버그 발생 위험이 있었습니다.
-   **해결책:** 중복되는 JSX 코드를 `MyLibraryListItem.tsx` 파일 내에 독립적인 `LibraryTagsGroup` 컴포넌트로 추출했습니다. 이제 양쪽 뷰에서 이 컴포넌트를 호출하여 코드 중복을 제거하고 유지보수성을 크게 향상시켰습니다.

**2. 데이터 접근 로직 안정성 및 일관성 강화**

-   **안전한 기본값 처리 (`??` 연산자 적용):**
    `|| 0` 구문은 유효한 값인 `0`을 `false`로 취급하여 버그를 유발할 수 있습니다. 이를 방지하기 위해 `null` 또는 `undefined`일 때만 기본값을 반환하는 `?? 0` 연산자로 교체했습니다.
    -   적용 대상: **`e교육`, `e시립구독`, `e시립소장`, `e경기`**의 재고 수량(`totalBooks`, `availableBooks`) 처리 로직

-   **에러 처리 로직 일관성 확보:**
    `isError`를 판단하는 로직을 `!!` 연산자를 사용하여 명시적으로 `boolean` 타입으로 변환하도록 통일했습니다. 이는 코드의 일관성을 높이고 가독성을 개선합니다.
    -   적용 대상: **`퇴촌`, `기타`, `e경기`, `e시립구독`, `e시립소장`** 등

이러한 변경을 통해 `MyLibraryListItem`은 더 간결하고 안정적인 컴포넌트가 되었으며, 향후 기능 확장 및 유지보수가 용이해졌습니다.


5d87b26
ahnbu
Sat Nov 8 17:17:42 2025 +0900
refactor(API): 응답 필드명을 camelCase로 표준화하여 일관성 확보
- **목표:** API 응답 데이터 구조의 일관성을 확보하여 코드 가독성과 유지보수성을 향상시킵니다.
- **문제점:** 기존 API 응답은 snake_case(`gwangju_paper`)와 한글 필드명('대출상태' 등)이 혼용되어 있어 프론트엔드에서 예외 처리가 필요하고 데이터 모델이 비일관적이었습니다. 이를 camelCase로 통일합니다.

**주요 변경 내역:**

1.  **최상위 키 통일:**
    -   `gwangju_paper` -> `gwangjuPaper`
    -   `book_list` -> `bookList`

2.  **`gwangjuPaper.bookList` 필드 영문화:**
    -   소장도서관 -> `libraryName`
    -   청구기호 -> `callNumber`
    -   대출상태 -> `loanStatus `
    -   반납예정일 -> `dueDate`

3.  **`gyeonggiEbookEdu.bookList` 필드 영문화:**
    -   소장도서관 -> `libraryName`
    -   도서명 -> `title`
    -   저자 -> `author`
    -   발행일 -> `publishDate`
    -   대출상태 -> `loanStatus `

4.  **관련 타입 및 로직 수정:**
    -   `library-checker/types.ts`와 `src/types.ts`의 관련 타입 정의를 모두 업데이트했습니다.
    -   변경된 필드명을 사용하도록 프론트엔드의 데이터 참조 로직을 수정했습니다.

이를 통해 모든 도서관 API 응답을 동일한 규칙으로 처리할 수 있게 되었습니다.


a9d8e0c
ahnbu
Sat Nov 8 15:46:28 2025 +0900
Stop tracking .docs/git_commit_history


8029dbf
ahnbu
Sat Nov 8 15:20:22 2025 +0900
refactor(api) : 시립(소장) 에러 메시지에 "소장형"이라고 명시


b3aa32b
ahnbu
Sat Nov 8 15:11:54 2025 +0900
refactor(api) : api응답변수 통일 작업 2차 - 경기도 전자도서관, 시립(구독,소장)도서관


96183e4
ahnbu
Sat Nov 8 14:43:01 2025 +0900
refactor(api) : api응답변수 통일 작업 1차 - (광주시립(종이책), 경기도 교육청 도서관


4aaa37b
ahnbu
Sat Nov 8 14:22:05 2025 +0900
docs: e경기(소장) 공식 api 문서 추가


4a6b238
ahnbu
Sat Nov 8 14:19:33 2025 +0900
docs: 경기도 전자도서관 API 관련 기술 결정 사항 기록
최근 발견된 경기도 전자도서관의 공식 OpenAPI(/api/open-search/ebook)를 검토한 결과, 해당 API는 서지 정보만 제공할 뿐 대출 가능 여부와 같은 핵심 재고 정보를 포함하지 않음을 확인했습니다.

현재 프로젝트에서 사용 중인 비공식 API(/api/service/search-engine)는 재고 정보를 제공하여 '대출 가능' 상태를 표시하는 핵심 기능을 구현하고 있습니다.

사용자 경험의 저하를 막기 위해, 기능적으로 우월한 현재의 비공식 API 사용을 유지하기로 결정했습니다. 이 의사 결정 과정과 배경을 DEVELOPMENT.md의 트러블슈팅 가이드에 상세히 기록하여 향후 개발 과정에서의 혼선을 방지하고자 합니다.

또한, 비공식 API가 중단될 경우를 대비한 장기적인 Fallback 전략(공식 API로의 점진적 기능 저하)도 함께 명시했습니다.


542e9e9
ahnbu
Sun Nov 2 14:08:12 2025 +0900
Refactor: Supabase 데이터베이스 성능 및 보안 경고 전체 수정
Supabase 대시보드의 'Database Linter'에서 보고된 다수의 성능 및 보안 관련 경고들을 해결했습니다. 이번 리팩터링은 프로젝트의 장기적인 안정성, 확장성, 보안을 확보하는 것을 목표로 합니다.

주요 변경 사항은 다음과 같습니다.

### 1. RLS 정책 성능 최적화 (auth_rls_initplan)
- **문제**: RLS 정책에서 `auth.uid()` 함수가 각 행마다 재평가되어, 데이터 증가 시 심각한 쿼리 성능 저하를 유발했습니다.
- **조치**: `user_library`, `user_settings`, `dev_notes` 테이블의 모든 RLS 정책에서 `auth.uid()`를 `(select auth.uid())` 서브쿼리 형태로 변경하여, 쿼리 당 단 한 번만 실행되도록 최적화했습니다.

### 2. 데이터베이스 함수 보안 강화 (function_search_path_mutable)
- **문제**: DB 함수들의 `search_path`가 고정되지 않아 잠재적인 보안 취약점에 노출되어 있었습니다.
- **조치**: `pg_proc`를 조회하여 모든 대상 함수의 정확한 서명(Signature)을 파악한 후, `ALTER FUNCTION`을 통해 `search_path`를 'public'으로 명시적으로 설정했습니다.

### 3. PostgreSQL 버전 업그레이드 (vulnerable_postgres_version)
- **문제**: 사용 중인 PostgreSQL 버전에 보안 취약점이 발견되었습니다.
- **조치**: Supabase 대시보드를 통해 보안 패치가 적용된 최신 버전으로 데이터베이스를 업그레이드했습니다.

### 4. 인증 보안 강화 (auth_otp_long_expiry)
- **문제**: 이메일 OTP의 만료 시간이 24시간(86400초)으로 매우 길어 보안에 취약했습니다.
- **조치**: OTP 만료 시간을 10분(600초)으로 대폭 단축하여 인증 토큰 탈취의 위험을 줄였습니다.

### 5. 데이터베이스 구조 개선 (extension_in_public)
- **문제**: `pg_trgm` 확장 프로그램이 `public` 스키마에 설치되어 있어 관리상 비효율적이었습니다.
- **조치**: 확장 프로그램 전용 `extensions` 스키마를 생성하고 `pg_trgm`을 이전하여 `public` 스키마와의 의존성을 분리했습니다.

### 6. 개발 문서 업데이트
- `DEVELOPMENT.md`에 '데이터베이스 유지보수 및 최적화 로그' 섹션을 신설했습니다.
- 이번에 진행된 모든 경고 해결 과정과 최종 조치 내역을 상세히 기록하여, 향후 유사 문제 발생 시 가이드로 활용할 수 있도록 문서화했습니다.

이번 수정을 통해 프로젝트의 잠재적인 병목 현상과 보안 위협을 선제적으로 제거하여, 더욱 안정적이고 빠른 서비스를 제공할 수 있는 기반을 마련했습니다.


5591bcd
ahnbu
Tue Oct 28 23:28:28 2025 +0900
refactor(data): API 응답 데이터 처리 및 디버깅 편의성 개선
신규 도서 추가 시 API 조회 실패 정보를 올바르게 저장하도록 데이터 처리 방식을 개선하고, 디버깅 편의성을 높이기 위해 'API 보기' 기능의 데이터 표시 구조를 조정합니다.

### 주요 변경 내용

1.  **신규 도서의 API 조회 실패 정보 유지 (`useBookStore.ts`)**
    -   **문제점**: 이전에는 신규 도서 추가 시 도서관 재고 API 조회에 실패하면, `null`이 DB에 저장되어 '원래 정보가 없는 것'과 '조회에 실패한 것'을 구분할 수 없었습니다.
    -   **원인**: `refreshBookInfo` 함수의 폴백(Fallback) 로직에서, `originalBook`의 `null` 상태인 재고 정보 속성에 접근하려다 런타임 에러가 발생하여 `catch` 블록의 롤백 로직이 실행되었기 때문입니다.
    -   **해결**: 폴백 조건문에 **옵셔널 체이닝(`?.`)**을 적용하여 `null` 값의 속성에 안전하게 접근하도록 수정했습니다. (예: `originalBook.siripEbookInfo?.errors`)
    -   **결과**: 이제 런타임 에러 없이, 신규 도서의 재고 조회 실패 시 **API가 반환한 에러 객체**가 DB의 `book_data`에 그대로 저장되어 추후 원인 분석이 용이해졌습니다.

2.  **'API 보기' JSON 키 순서 재정렬 (`MyLibraryBookDetailModal.tsx`)**
    -   **문제점**: DB의 `jsonb` 타입 특성으로 인해 'API 보기' 기능으로 확인하는 `book_data`의 키 순서가 네트워크 탭의 원본 응답과 달라 비교하기 불편했습니다.
    -   **해결**: `handleApiButtonClick` 함수 내에서 DB 데이터를 조회한 후, **화면에 표시하기 직전에** 원하는 순서(`desiredKeyOrder`)에 따라 키를 재정렬하는 로직을 추가했습니다.
    -   **결과**: DB에는 `jsonb`의 효율적인 저장 방식을 유지하면서, 디버깅 시에는 네트워크 응답과 동일한 순서로 정렬된 JSON을 확인할 수 있게 되어 편의성이 크게 향상되었습니다.

### 영향 범위
-   `useBookStore.ts`: `refreshBookInfo` 함수의 데이터 처리 로직 수정.
-   `MyLibraryBookDetailModal.tsx`: 'API 보기' 버튼 클릭 시 데이터 표시 방식 수정.
-   데이터베이스: 신규 책 추가 시 `user_library` 테이블의 `book_data` 컬럼에 에러 객체가 저장될 수 있음. (저장 방식 변경 없음)


78a9154
ahnbu
Tue Oct 28 19:36:35 2025 +0900
feat(library): AND 조건 필터링 및 초기 화면 맞춤설정 기능 구현
'좋아요' 필터와 '태그' 필터를 동시에 적용(AND 조건)하여 책을 검색하는 기능을 구현하고, 관련 설정을 관리하는 UI를 개선합니다. 이제 사용자는 내 서재에 처음 진입할 때 적용될 기본 필터(좋아요, 태그, 또는 둘 다)와 보기 방식을 자유롭게 설정할 수 있습니다.

### 1. 백엔드: AND 조건 필터링 RPC 함수 구현

-   **Supabase SQL 함수 (`get_books_by_tags`) 수정**:
    -   기존 함수 시그니처를 `(tags_to_filter text[], filter_by_favorites boolean)`으로 확장했습니다.
    -   SQL 쿼리 내 `WHERE` 절을 수정하여, `tags_to_filter`와 `filter_by_favorites` 파라미터를 기반으로 AND 조건 필터링을 수행하도록 로직을 변경했습니다.
    -   두 파라미터가 모두 비어있거나 `false`일 경우 전체 목록을 반환하여 유연성을 확보했습니다.

### 2. 프론트엔드: 데이터 흐름 통합 및 UI 로직 재설계

-   **상태 관리 로직 통합 (`useBookStore.ts`)**:
    -   `filterLibraryByFavorites` 관련 상태 및 함수(`libraryFavoritesFilterResults` 등)를 모두 제거하고, `filterLibraryByTags` 하나로 데이터 요청 창구를 통일했습니다.
    -   `filterLibraryByTags`는 이제 `(tagIds: string[], filterByFavorites: boolean)` 인자를 받아 수정된 Supabase RPC를 호출합니다.
    -   책 정보를 수정하는 모든 내부 함수(`removeFromLibrary`, `toggleFavorite` 등)에서 분리된 필터 결과 배열에 대한 참조를 제거하여 코드 복잡도를 낮췄습니다.

-   **컴포넌트 로직 리팩토링 (`MyLibrary.tsx`)**:
    -   **역할 분리**: `useEffect` 훅을 2개로 분리하여 역할을 명확히 했습니다.
        1.  `settings` 동기화 `useEffect`: `useSettingsStore`의 변경사항을 컴포넌트의 로컬 상태(`activeTags`, `showFavoritesOnly`)에 반영하는 역할만 수행합니다.
        2.  데이터 로딩 `useEffect`: 로컬 상태가 변경될 때마다 통합된 `filterLibraryByTags` 함수를 호출하여 실제 데이터 필터링을 요청합니다.
    -   **상태 중심 설계**: 모든 필터 핸들러(`handleTagClick` 등)는 이제 API를 직접 호출하지 않고 로컬 상태만 변경합니다. 실제 데이터 로딩은 상태 변경에 따라 `useEffect`가 자동으로 처리합니다.
    -   **`useMemo` 로직 단순화**: `sortedAndFilteredLibraryBooks`는 이제 서버 필터링이 필요할 때 `libraryTagFilterResults`라는 단일 결과 배열만 참조하도록 수정되었습니다.

### 3. UI/UX 개선: 설정 모달 구조 변경 (`SettingsModal.tsx`)

-   **'초기화면' 탭 신설**:
    -   기존 '표시옵션' 탭에 있던 '기본 보기 방식', '좋아요 필터', '기본 태그 필터' 설정을 "초기화면"이라는 별도의 탭으로 분리하여 관련 설정을 그룹화했습니다.
    -   이에 따라 탭 네비게이션과 하단 저장/취소 버튼의 표시 로직을 수정했습니다.

-   **AND 조건 허용**:
    -   '좋아요' 필터와 '태그' 필터가 서로를 해제하던 상호 배타 로직을 제거했습니다. 이제 사용자는 두 필터를 동시에 선택하여 기본 AND 조건 필터를 설정할 수 있습니다.

-   **사용자 편의 기능 추가**:
    -   '기본 태그 필터' 섹션에 선택된 태그 목록을 보여주는 "필터링 미리보기" 텍스트와, 모든 선택을 해제하는 "초기화" 버튼을 추가하여 메인 화면의 필터 UI와 경험을 통일했습니다.


7a54546
ahnbu
Tue Oct 28 18:01:08 2025 +0900
feat(settings): 내 서재 초기 표시 방식 맞춤설정 기능 구현
사용자가 내 서재에 처음 진입할 때의 화면을 개인화할 수 있도록 '초기 표시 방식 맞춤설정' 기능을 추가합니다. 이제 사용자는 선호하는 보기 방식(카드/그리드)과 기본 필터('좋아요' 또는 특정 태그)를 미리 설정할 수 있습니다.

### 주요 구현 내용

1.  **데이터베이스 스키마 확장 (`user_settings` 테이블)**:
    -   `default_view_type` (text): 기본 보기 방식을 저장합니다. (기본값: 'card')
    -   `default_filter_favorites` (boolean): '좋아요' 필터 기본 적용 여부를 저장합니다. (기본값: false)
    -   `default_filter_tag_ids` (jsonb): 기본으로 적용할 태그 ID 배열을 저장합니다. (기본값: '[]')

2.  **설정 UI 통합 및 개선 (`SettingsModal.tsx`)**:
    -   '표시옵션' 탭에 '내 서재 초기 표시 설정' 섹션을 신설했습니다.
    -   기존 '기본 보기 방식' 설정을 이 섹션으로 통합하고, '초기 필터 설정'('좋아요', '태그') UI를 함께 배치하여 연관된 설정들을 그룹화했습니다.
    -   '좋아요' 필터와 '태그' 필터를 독립적으로 선택할 수 있도록 UI 로직을 수정하여, 향후 AND 조건 필터링을 위한 기반을 마련했습니다.

3.  **초기 상태 적용 로직 구현 (`MyLibrary.tsx`)**:
    -   컴포넌트가 마운트되거나 `settings`가 변경될 때 실행되는 통합 `useEffect` 훅을 구현했습니다.
    -   이 훅은 `useSettingsStore`에서 저장된 `defaultViewType`, `defaultFilterFavorites`, `defaultFilterTagIds` 값을 읽어와 `viewType`, `showFavoritesOnly`, `activeTags` 상태를 자동으로 설정합니다.
    -   '필터 초기화' 기능(`resetLibraryFilters`)이 이제 모든 필터를 제거하는 대신, 사용자가 설정한 기본 필터 상태로 되돌아가도록 동작을 변경했습니다.

### 현재 상태 및 다음 단계

-   이번 커밋은 프론트엔드의 UI와 상태 관리 로직 변경까지만 포함합니다.
-   '좋아요'와 '태그' 필터를 동시에 선택할 수는 있으나, 아직 실제 데이터 필터링은 AND 조건으로 동작하지 않습니다.
-   다음 단계는 Supabase RPC 함수를 수정하여 백엔드에서 실제 AND 조건 필터링을 구현하는 것입니다.


ab54f71
ahnbu
Tue Oct 28 17:39:18 2025 +0900
feat(settings): 사용자의 기본 보기 방식 설정 기능 추가
사용자가 내 서재의 초기 보기 방식을 '카드 뷰' 또는 '그리드 뷰'로 직접 설정할 수 있는 기능을 추가합니다. 이를 통해 개인화된 사용자 경험을 제공하고, 앱 진입 시 선호하는 레이아웃으로 즉시 탐색을 시작할 수 있습니다.

### 구현 내용

1.  **데이터베이스 스키마 확장 (`user_settings` 테이블)**:
    -   `default_view_type` (text 타입) 컬럼을 추가하여 사용자의 선택을 저장합니다.
    -   기존 사용자를 위해 기본값으로 `'card'`를 설정했습니다.

2.  **타입 정의 업데이트 (`types.ts`)**:
    -   `UserSettings` 인터페이스에 `defaultViewType: ViewType` 속성을 추가하여 타입 안정성을 확보했습니다.

3.  **설정 모달 UI 추가 (`SettingsModal.tsx`)**:
    -   '표시옵션' 탭에 '기본 보기 방식' 섹션을 새로 추가했습니다.
    -   사용자가 '카드 뷰'와 '그리드 뷰' 중 하나를 선택할 수 있는 직관적인 버튼 그룹 UI를 구현했습니다.

4.  **설정 적용 로직 구현 (`MyLibrary.tsx`)**:
    -   `MyLibrary` 컴포넌트가 마운트될 때, `useSettingsStore`에서 저장된 `defaultViewType` 값을 읽어와 `viewType` 상태의 초기값으로 설정합니다.
    -   설정이 비동기적으로 로드되는 경우를 대비하여, `useEffect`를 통해 설정값이 변경되면 `viewType` 상태가 동기화되도록 구현했습니다.

5.  **기본값 처리 로직 강화 (`useSettingsStore.ts`)**:
    -   `getDefaultSettings` 함수에 `defaultViewType: 'card'`를 추가하여, 신규 사용자나 설정이 없는 사용자에게도 올바른 기본값이 적용되도록 보장했습니다.

### 기대 효과

-   **사용자 경험 개인화**: 사용자가 가장 선호하는 뷰 타입으로 서재를 시작할 수 있어 편의성이 증대됩니다.
-   **유지보수성 향상**: 보기 방식 설정이 중앙화된 `useSettingsStore`를 통해 관리되어 코드의 일관성과 유지보수성이 향상됩니다.


bc33aa0
ahnbu
Tue Oct 28 17:25:30 2025 +0900
doc : 캐싱 실패: 동일한 요청에도 계속 Cache MISS가 발생하는 경우 추가


e90f974
ahnbu
Tue Oct 28 17:24:43 2025 +0900
fix(worker): 도서관 재고 API 캐싱 오류 수정
도서관 도서 재고를 확인하는 Cloudflare Worker에 견고한 캐싱 계층을 도입합니다. 이 커밋의 주목표는 동일한 도서에 대한 반복 요청의 성능을 크게 향상시키고, 크롤링 대상 도서관 웹사이트의 부하를 줄이며, 더 빠른 사용자 경험을 제공하는 것입니다.

### 문제 상황

이전에는 캐싱 메커니즘이 의도대로 작동하지 않아, 동일한 요청에 대해서도 지속적으로 `Cache MISS`가 발생하는 문제가 있었습니다. 모든 API 호출은 2-3초가 소요되는 새로운 크롤링 프로세스를 유발했습니다. 문제의 근본 원인은 두 가지였습니다.
1. 캐시에 저장되는 `Response` 객체에 필수적인 `Cache-Control` 헤더가 누락되어, Cloudflare 캐시가 응답을 효과적으로 저장하지 못했습니다.
2. 캐시 키로 URL 문자열을 사용하는 방식이, 정식 `Request` 객체를 사용하는 것보다 덜 명시적이고 안정성이 떨어졌습니다.

### 해결 방안 및 구현 상세

이번 커밋은 캐싱 전략을 근본적으로 개선하여 문제를 해결합니다.

1.  **명시적인 캐시 키 객체 사용**:
    -   단순한 URL 문자열 대신, 요청 본문의 SHA-256 해시값으로 생성된 고유 경로(`/cache/<hash>`)와 `GET` 메서드를 갖는 전용 `Request` 객체를 생성합니다.
    -   이 `Request` 객체를 `cache.match()`와 `cache.put()` 양쪽에서 일관되게 사용하여 신뢰할 수 있는 캐시 조회를 보장합니다.

2.  **`Cache-Control` 헤더 추가**:
    -   이번 수정의 핵심으로, 캐시 MISS 발생 시 생성되는 `Response` 객체에 `Cache-Control` 헤더를 추가했습니다.
    -   헤더 값을 `public, max-age=43200`으로 설정하여, 캐시가 해당 응답을 저장하고 12시간 동안 유효한 것으로 간주하도록 명시합니다. 이 변경 사항이 성공적인 캐싱을 가능하게 하는 결정적인 역할을 합니다.

3.  **로직 개선**:
    -   전체 캐싱 로직을 Cloudflare의 권장 사례에 더 부합하도록 개선했습니다.
    -   오류가 포함된 응답(`hasCacheBlockingError`)은 `Cache-Control: no-store`를 설정하여 캐싱 대상에서 명시적으로 제외함으로써, 잘못된 데이터가 캐시에서 제공되는 것을 방지합니다.

### 기대 효과

-   **성능 향상**: 동일 도서에 대한 후속 요청은 이제 캐시에서 직접 처리되어, 응답 시간이 약 2000ms에서 10ms 미만으로 단축됩니다 (99% 이상 개선).
-   **외부 부하 감소**: 도서관 웹사이트로 전송되는 크롤링 요청 수가 급격히 줄어들어, 더 책임감 있는 서비스 운영이 가능해집니다.
-   **사용자 경험 개선**: 사용자는 이전에 검색했던 책의 재고 확인 결과를 거의 즉시 받아볼 수 있습니다.
-   **코드 안정성**: 새로운 구현은 표준 HTTP 캐싱 프로토콜을 준수하여 더 견고하고 디버깅이 용이합니다.

이번 변경은 애플리케이션의 성능과 확장성에 있어 중요한 진전을 이루었습니다.


5fffd4c
ahnbu
Tue Oct 28 15:51:05 2025 +0900
refactor(worker): Cloudflare Worker를 TypeScript로 전환
Cloudflare Worker 코드(`library-checker`)를 기존 JavaScript에서 TypeScript로 완전히 마이그레이션했습니다. 이를 통해 코드의 안정성을 대폭 향상시키고, 타입 추론 및 자동 완성 기능을 활용하여 향후 유지보수성과 개발 생산성을 높였습니다.

### 배경
- **타입 안정성 부재:** 기존 JavaScript 코드는 런타임에서만 오류를 발견할 수 있어, 크롤링 데이터 구조 변경이나 API 응답 변화에 취약했습니다.
- **개발자 경험:** `any` 타입의 남용으로 인해 코드의 흐름을 추적하기 어렵고, VS Code와 같은 에디터의 타입 지원 기능을 온전히 활용하지 못했습니다.
- **거짓 양성 오류:** 에디터가 번들링된 JS 파일을 분석하며 실제 런타임과 무관한 수많은 타입 오류 경고를 표시하여 개발에 혼란을 주었습니다.

### 주요 변경사항
1.  **개발 환경 구성:**
    -   `typescript` 및 `@cloudflare/workers-types` 패키지를 설치하여 타입 검사 환경을 구축했습니다.
    -   `tsconfig.json`을 추가하여 엄격한(`strict: true`) 타입 검사 규칙을 적용했습니다.
    -   `wrangler.jsonc`의 진입점(`main`)을 `src/index.js`에서 `src/index.ts`로 변경했습니다.

2.  **타입 시스템 도입 (`src/types.ts`):**
    -   Worker가 다루는 모든 핵심 데이터 구조(API 요청/응답, 도서관별 결과 등)에 대한 타입을 `types.ts` 파일에 명시적으로 정의했습니다.
    -   `Env` 인터페이스를 정의하여 환경 변수에 대한 타입 안정성을 확보했습니다.

3.  **코드 리팩토링 및 타입 적용:**
    -   `index.js`를 `index.ts`로 변경하고, 모든 함수 시그니처(파라미터, 반환 값)에 타입을 적용했습니다.
    -   `catch (error)` 블록에서 `instanceof Error` 타입 가드를 사용하여 `unknown` 타입 문제를 해결했습니다.
    -   `Promise.allSettled`의 결과를 처리할 때, `status`를 먼저 확인하여 타입을 좁히는 안전한 로직으로 개선했습니다.
    -   Node.js 환경에 의존적인 `Buffer` 관련 코드를 제거하고, Workers 환경 표준인 `btoa`만 사용하도록 수정했습니다.
    -   `cache.put` 메서드를 최신 Wrangler 사양에 맞게 2개의 인자만 사용하도록 수정하여 CORS preflight 오류를 해결했습니다.

### 기대 효과
- **버그 사전 방지:** 컴파일 시점에 타입 오류를 발견하여 런타임 에러 발생 가능성을 크게 줄입니다.
- **유지보수성 향상:** 코드의 가독성이 향상되고, 데이터의 흐름을 명확하게 추적할 수 있습니다.
- **생산성 증대:** 에디터의 강력한 자동 완성 및 타입 힌트 기능을 통해 더 빠르고 정확한 코딩이 가능해졌습니다.


078d16a
ahnbu
Tue Oct 28 13:34:08 2025 +0900
refactor(data): 책 상세 api를 api와 일치하도록 단순화 및 중복 파생 데이터 제거
기존에는 DB에 저장되는 `book_data`에 API 원본 데이터와 함께 UI 표시를 위한 파생 데이터(`toechonStock`, `filteredGyeonggiEbookInfo` 등)가 중복으로 저장되었습니다. 이는 데이터 불일치 위험을 초래하고, 데이터 모델을 복잡하게 만들며, 유지보수성을 저해하는 문제가 있었습니다.

이를 해결하기 위해, DB에는 순수 API 응답만 저장하고 파생/계산은 UI 컴포넌트에서 실시간으로 처리하도록 구조를 변경했습니다. 이를 통해 데이터 모델의 책임과 역할이 명확해졌습니다.

주요 변경사항:
- **`utils/bookDataCombiner.ts`**:
  - `createBookDataFromApis` 함수에서 `toechonStock`, `otherStock`, `filteredGyeonggiEbookInfo` 등 파생 데이터를 생성하는 로직을 모두 제거했습니다.
  - 이제 이 함수는 순수 API 응답을 조합하는 역할만 수행합니다.

- **`stores/useBookStore.ts`**:
  - `refreshBookInfo`의 데이터 복원(Fallback) 로직에서 제거된 파생 필드(`toechonStock` 등)에 대한 처리를 삭제했습니다.
  - 이제 오직 원본 API 객체(`gwangjuPaperInfo` 등)의 유효성만 검사하고 복원합니다.

- **`components/MyLibraryListItem.tsx` & `MyLibraryBookDetailModal.tsx`**:
  - `book.toechonStock`과 같이 중복 저장된 파생 데이터를 직접 참조하던 부분을 수정했습니다.
  - 이제 `book.gwangjuPaperInfo.toechon_total_count`와 같이 원본 데이터 소스에서 직접 값을 읽어와 UI에 표시합니다.
  - 이를 통해 UI는 항상 최신 원본 데이터를 기반으로 렌더링됩니다.


dfb753f
ahnbu
Tue Oct 28 13:02:09 2025 +0900
docs: 시립구독 크롤링 관련 문서 업데이트


984cae4
ahnbu
Tue Oct 28 12:58:39 2025 +0900
refactor(worker): 시립(구독형) 크롤링에서 세션쿠기 제거 & 헤더 보강
본문:
간헐적으로 HTTP 400 오류가 발생하던 광주시립도서관(구독형) 크롤링 로직을 전면 재검토하고, 복잡성을 제거하여 안정성을 크게 향상시켰습니다.

문제 분석:
이전에 시도했던 KV를 이용한 세션 캐싱 전략이 오히려 동시 요청 상황에서 서버의 봇 탐지를 유발하는 역효과를 낳는 것으로 분석되었습니다. 반면, 매번 새로운 세션을 요청하는 단순한 2단계 요청 방식이 더 높은 성공률을 보였습니다. 그러나 이 방식 역시 헤더 구성이 단순하여 간헐적인 차단이 발생하는 약점이 있었습니다.

개선 사항:
성공률이 높았던 단순 2단계 요청 패턴의 장점은 계승하되, 실패 원인이었던 헤더 위장술을 대폭 강화하는 방향으로 리팩토링했습니다.

    KV 세션 캐싱 로직 제거:

        동시성 문제를 유발하고 복잡성을 높였던 getCachedSession, refreshAndCacheSession 헬퍼 함수와 KV 관련 로직을 모두 제거했습니다.

        이를 통해 각 요청이 완전히 독립적으로 동작하도록 하여 예측 가능성을 높였습니다.

    브라우저 헤더 모방 강화:

        세션을 획득하는 첫 번째 요청부터 Sec-Fetch-* 계열의 헤더를 포함한 정교한 헤더 세트를 사용하여, 실제 브라우저의 첫 방문과 매우 유사하게 동작하도록 수정했습니다.

        검색을 수행하는 두 번째 요청에도 일관된 헤더를 상속하고, Referer와 Sec-Fetch-Site: 'same-origin'을 명시하여 자연스러운 사용자 행동 맥락을 부여했습니다.

이번 리팩토링은 복잡한 해결책보다 문제의 본질을 파악하고 단순하면서도 견고한 접근법을 채택하는 것이 더 효과적임을 보여줍니다. 이를 통해 searchSiripEbookSubs 함수의 안정성을 확보하고, 향후 유지보수성을 크게 개선했습니다.


cb6bd45
ahnbu
Tue Oct 28 12:40:53 2025 +0900
fix(worker): 세션쿠키 적용 이전으로 되돌림
왜냐하면, 세션쿠키나 KV 방식을 적용하고 여러번 수정했는데, 계속 세션 에러 생김. 즉, 이게 문제가 아니라는 판단.


baf95f8
ahnbu
Mon Oct 27 19:00:28 2025 +0900
fix(worker): 시립(구독형) 크롤링의 '조용한 실패' 문제 해결
본문:
시립도서관 구독형 전자책 크롤링 시, 세션 만료 후에도 에러 없이 "결과 없음"으로만 응답하여 자동 복구가 되지 않던 '조용한 실패(Silent Failure)' 문제를 근본적으로 해결했습니다.

원인 분석:
이전 코드의 parseSiripE-bookSubsHTML 함수는 만료된 세션으로 인해 유효하지 않은 HTML(예: 로그인 페이지)을 받았을 때, 내부 파싱 오류를 catch한 후 **에러 정보를 담은 객체를 정상적으로 return**했습니다.

이로 인해 상위 함수인 searchSiripEbookSubs는 에러가 발생했음을 인지하지 못했고, 세션을 갱신하고 재시도하는 catch 블록이 실행되지 않았습니다. 결과적으로 만료된 세션이 KV 저장소에 계속 남아있어, 이후의 모든 요청이 지속적으로 실패하는 악순환이 발생했습니다.

해결 방안:
파싱 함수와 검색 함수의 역할을 명확히 하여, 실패 신호가 확실하게 전파되도록 수정했습니다.

    parseSiripEbookSubsHTML 로직 변경:

        이제 유효하지 않은 HTML을 받으면 에러 객체를 반환하는 대신, **명시적으로 에러를 throw**합니다.

        정상적인 검색 결과 페이지에만 존재하는 특정 CSS 선택자(.book_resultList)를 확인하여, 세션 만료로 인한 비정상 페이지를 더 능동적이고 정확하게 감지하도록 개선했습니다.

    searchSiripEbookSubs 재시도 로직 활성화:

        parseSiripEbookSubsHTML이 throw한 에러를 catch 블록이 정상적으로 감지하게 되었습니다.

        에러 감지 시(세션 만료 또는 HTTP 에러), 기존의 만료된 세션 정보를 KV에서 삭제하고, 새로운 세션을 발급받아 단 한 번 검색을 자동 재시도합니다.

이번 수정을 통해 크롤링 시스템의 자동 복구(Self-Healing) 능력이 대폭 향상되었습니다. 이제 세션이 만료되더라도 시스템이 스스로 문제를 인지하고 해결하여, 장기적으로 훨씬 더 안정적인 재고 정보 조회가 가능해졌습니다.


c246a10
ahnbu
Mon Oct 27 18:36:32 2025 +0900
fix(data): 재고 갱신 실패 시 기존 데이터가 초기화되는 문제 수정
본문:
도서 재고 정보 갱신(refreshBookInfo) 시, 특정 도서관 API 호출이 실패했을 때 해당 재고 정보가 (0/0)으로 초기화되던 버그를 수정했습니다.

원인 분석:
useBookStore의 refreshBookInfo 함수 내부에 있는 데이터 폴백(Fallback) 로직이 API 실패 응답을 제대로 감지하지 못했습니다. API가 null이나 undefined 대신, 에러 정보가 포함된 유효한 JSON 객체({ "errors": ... } 등)를 반환할 경우, 폴백 조건이 이를 정상 응답으로 오판하여 기존의 유효한 재고 데이터를 에러 객체로 덮어씌웠습니다. 이로 인해 UI에서는 재고가 0으로 표시되는 문제가 발생했습니다.

해결 방안:
refreshBookInfo 함수의 폴백 로직을 대폭 강화하여, 각 도서관 API의 고유한 에러 응답 구조를 명시적으로 확인하도록 수정했습니다.

    gwangjuPaperInfo, gyeonggiEbookInfo: 'error' in ... 조건을 추가하여 객체 내 error 프로퍼티를 확인합니다.

    GyeonggiEduEbookInfo: error_count > 0 조건을 추가하여 에러 발생 여부를 확인합니다.

    siripEbookInfo: .errors 객체의 존재 여부를 확인하여 중첩된 에러 구조를 정확히 감지합니다.

    toechonStock, otherStock 등 파생 데이터도 원본 API(gwangjuPaperInfo)의 에러 상태를 기반으로 폴백 여부를 결정하도록 수정했습니다.

이번 수정을 통해, 이제 재고 갱신 중 일부 API가 실패하더라도 해당 재고 정보는 가장 최근에 성공했던 데이터를 그대로 유지하게 됩니다. 예를 들어, (녹색) e시립구독(1/1) 상태에서 갱신이 실패하면 (빨간색) e시립구독(1/1)으로 표시되어, 사용자에게 데이터 손실 없이 오류 상황만을 명확히 전달할 수 있게 되었습니다. 이를 통해 전체적인 데이터의 안정성과 사용자 경험을 향상시켰습니다.


d859426
ahnbu
Mon Oct 27 18:30:53 2025 +0900
fix(worker): 크롤링 안정성 및 캐시 로직 전면 개선
본문:
Cloudflare Worker에서 간헐적으로 발생하던 크롤링 실패와 로컬 환경에서 캐시가 동작하지 않던 문제를 근본적으로 해결했습니다.

1. 시립(구독형) 크롤링 안정성 강화

    문제: 세션 획득 실패: HTTP 400 오류가 반복적으로 발생. 이는 도서관 서버의 강화된 안티-스크래핑 정책이 세션 획득을 위한 최초 접속 단계부터 봇을 탐지하여 차단했기 때문입니다.

    해결:

        세션 쿠키 캐싱 도입: Cloudflare KV를 사용하여 한 번 발급받은 세션 쿠키를 25분간 재사용하도록 로직을 변경했습니다. 이를 통해 매번 새로운 세션을 요청하는 비정상적인 패턴을 제거하고 실제 사용자처럼 동작하도록 개선했습니다.

        헤더 모방 강화: 세션을 새로 발급받는 refreshAndCacheSession 함수에도 Sec-Fetch-* 등 실제 브라우저와 유사한 헤더를 적용하여 초기 접속 시 차단될 가능성을 최소화했습니다.

        자동 복구 로직 추가: 검색 요청이 HTTP 400으로 실패할 경우, 캐시된 세션이 만료된 것으로 간주하고 캐시를 삭제한 후 자동으로 1회 재시도하는 로직을 추가하여 견고성을 높였습니다.

2. 캐시 로직 근본 문제 해결

    문제: 로컬 및 배포 환경에서 Cache HIT!가 발생하지 않고, 매번 새로 크롤링하는 현상 발생. POST 요청에 대한 응답은 Cache API가 기본적으로 캐싱하지 않기 때문이었습니다.

    해결:

        GET 응답 모방: POST 요청에 대한 최종 응답(finalResponse)을 생성한 후, 캐시 저장을 위해 해당 응답의 본문과 헤더를 복사하여 GET 요청에 대한 응답처럼 보이는 별도의 cacheableResponse 객체를 생성했습니다. 이 객체를 캐시에 저장함으로써 Cache API가 정상적으로 동작하도록 수정했습니다.

        await 적용: 로컬 테스트 시 ctx.waitUntil의 비동기 동작으로 인해 캐시 저장이 누락되는 현상을 방지하기 위해, await cache.put()으로 변경하여 캐시 저장이 완료될 때까지 명시적으로 기다리도록 수정했습니다.

        에러 감지 로직 수정: hasCacheBlockingError 함수가 sirip_ebook의 중첩된 에러 구조를 정확히 감지하도록 수정하여, 불완전한 응답이 캐시에 저장되는 것을 방지했습니다.

이번 수정으로 크롤링 성공률과 안정성이 대폭 향상되었으며, 캐시 시스템이 의도대로 동작하여 불필요한 크롤링을 줄이고 응답 속도를 개선했습니다.


456891b
ahnbu
Mon Oct 27 16:36:02 2025 +0900
fix(worker): 시립(구독형) 크롤링 인증 로직 강화 및 문서 업데이트
본문:
세션 획득 실패: HTTP 400 오류가 간헐적으로 발생하는 문제를 해결하고, 관련 기술적 내용을 DEVELOPMENT.md에 상세히 반영했습니다.

주요 변경 사항:

    크롤링 로직 강화 (searchSiripEbookSubs)

        원인: 도서관 서버가 세션 획득을 위한 최초 접속 단계부터 정교한 헤더 검증을 수행하여, 단순화된 헤더를 가진 요청을 봇으로 탐지하고 차단하고 있었습니다.

        해결: 세션 획득(1단계)과 검색(2단계) 요청 모두에 Sec-Fetch-* 계열 헤더 등 실제 브라우저와 거의 동일한 헤더 구성을 적용했습니다. 특히, 각 단계의 맥락에 맞게 Sec-Fetch-Site 값을 'none'과 'same-origin'으로 다르게 설정하여 사용자 행동 패턴을 더욱 정교하게 모방했습니다.

    개발 문서 업데이트 (DEVELOPMENT.md)

        트러블슈팅 가이드의 "세션 쿠키가 필요한 경우" 항목을 이번에 발견된 다단계 방어 정책과 "완전한 브라우저 헤더 모방" 해결 전략에 맞게 내용을 전면 개정했습니다.

        문제의 진화 과정(1차/2차 방어)과 단계별 헤더 구성의 중요성을 명시하여, 향후 유사 문제 발생 시 근본적인 해결책을 찾는 데 도움이 되도록 했습니다.

이번 업데이트를 통해 크롤링 로직의 장기적인 안정성을 확보하고, 프로젝트의 기술적 해결 과정을 체계적으로 문서화했습니다.


ad92c6b
ahnbu
Mon Oct 27 15:49:48 2025 +0900
fix(ui): 상세 모달에서 상태(태그) 업데이트 시 스크롤 위치 유지
본문:
모바일 환경의 MyLibraryBookDetailModal에서 태그를 추가/삭제하거나 다른 상태를 업데이트할 때, 스크롤 위치가 최상단으로 초기화되는 문제를 해결했습니다.

원인:
useBookStore의 전역 상태가 변경되면 모달 컴포넌트가 새로운 book 데이터로 리렌더링되면서, 스크롤 컨테이너의 scrollTop이 0으로 리셋되었습니다.

해결:
useRef와 useLayoutEffect를 사용하여 스크롤 위치를 기억하고 복원하는 로직을 구현했습니다.

    상태 변경을 유발하는 핸들러(handleAddTag, handleRemoveTag) 실행 직전에 현재 스크롤 위치를 useRef에 저장합니다.

    컴포넌트가 리렌더링된 직후 useLayoutEffect를 통해 저장된 위치로 스크롤을 즉시 복원합니다.

이를 통해 상태가 변경되어도 사용자는 보던 위치에서 벗어나지 않게 되어, 특히 스크롤이 필수적인 모바일 환경에서의 사용자 경험(UX)을 크게 향상시켰습니다.


64d65db
ahnbu
Mon Oct 27 15:42:29 2025 +0900
feat(worker): 크롤링 인증 로직 개선 및 트러블슈팅 가이드 문서화
본문:
Cloudflare Worker의 도서관 크롤링 안정성을 강화하고, 주요 문제 해결 과정을 DEVELOPMENT.md에 상세히 기록했습니다.

주요 변경 사항:

    시립(구독형) 크롤링 오류 해결 (HTTP 400)

        searchSiripEbookSubs 함수에 2단계 요청 프로세스를 도입했습니다.

        먼저 세션 쿠키를 획득한 후, 해당 쿠키를 Cookie 및 Referer 헤더에 담아 검색을 요청하는 방식으로 서버의 안티-스크래핑 정책을 우회하여 문제를 해결했습니다.

    DEVELOPMENT.md 트러블슈팅 가이드 대폭 강화

        [유형 1] 세션 쿠키: 이번에 해결한 광주시립도서관(구독형) 사례를 바탕으로 세션 쿠키 방식의 크롤링 해결 과정을 상세히 기술했습니다.

        [유형 2] 동적 토큰: 기존에 해결했던 경기도 전자도서관(구독형) 사례를 동적 인증 토큰 방식의 대표 해결책으로 함께 정리했습니다.

        이를 통해 향후 발생할 수 있는 두 가지 대표적인 크롤링 인증 문제를 체계적으로 진단하고 해결할 수 있는 가이드를 마련했습니다.

이번 업데이트는 API의 안정성을 높이는 동시에, 프로젝트의 기술적 자산과 지식 공유 체계를 강화하여 장기적인 유지보수성을 크게 향상시켰습니다.


b0072fc
ahnbu
Mon Oct 27 15:23:34 2025 +0900
refactor(components): MyLibrary 컴포넌트 분리를 통한 가독성 및 유지보수성 향상
기존에 1500라인이 넘어가던 거대 컴포넌트 `MyLibrary.tsx`를 역할에 따라 세분화하여 구조를 개선했습니다. 이번 리팩토링은 코드의 복잡도를 낮추고, 각 컴포넌트의 책임을 명확히 하여 향후 기능 추가 및 수정 작업을 용이하게 만드는 데 목적이 있습니다.

### 주요 변경 사항

#### 1. `MyLibraryListItem.tsx` 신규 생성
- **역할**: `MyLibrary.tsx`의 카드 뷰 및 그리드 뷰에서 개별 도서 아이템을 렌더링하는 로직을 담당합니다.
- **분리 내용**:
  - 카드/그리드 뷰 JSX 템플릿
  - 아이템 내에서만 사용되는 로컬 컴포넌트 (`ReadStatusDropdown`, `LibraryTag`)
- **기대 효과**: `MyLibrary.tsx`의 가장 큰 JSX 덩어리를 제거하여 부모 컴포넌트의 가독성을 크게 향상시켰습니다. `React.memo`를 적용하여 불필요한 리렌더링을 방지하고 성능을 최적화했습니다.

#### 2. `MyLibraryToolbar.tsx` 신규 생성
- **역할**: 서재 상단의 모든 컨트롤 UI(검색, 필터, 정렬, 일괄 작업 버튼 등)를 담당합니다.
- **분리 내용**:
  - 검색 입력창, 뷰 타입 토글 버튼
  - `TagFilter` 컴포넌트 호출부
  - 정렬 드롭다운 메뉴 및 관련 로직 (`sortDropdownOpen` 상태 등)
  - 선택된 아이템 수 표시 및 일괄 관리(태그, 삭제, 즐겨찾기) 버튼
- **기대 효과**: UI 로직과 상태 관리 로직을 분리했습니다. `MyLibraryToolbar`는 UI 표시에만 집중하고, 모든 상태와 이벤트는 `props`를 통해 부모(`MyLibrary`)로부터 주입받는 구조로 변경되었습니다.

#### 3. `MyLibrary.tsx` 리팩토링
- **역할**: 상태 관리와 비즈니스 로직을 총괄하는 **컨테이너(Container) 컴포넌트**로 역할이 명확해졌습니다.
- **변경 내용**:
  - `MyLibraryListItem`과 `MyLibraryToolbar`를 호출하고 필요한 `props`를 전달합니다.
  - 툴바와 리스트 아이템에서 사용되던 로컬 상태(`sortDropdownOpen` 등)와 헬퍼 함수들을 제거하여 코드를 대폭 간소화했습니다.
  - 검색 기능이 정상 동작하도록 누락되었던 `useEffect` 훅(debouncedSearchQuery 관련)을 복원했습니다.

### 타입 정의 추가
- `types.ts`에 `ViewType` ('card' | 'grid') 타입을 추가하여 프로젝트 전반에서 일관된 타입 사용을 보장합니다.

이번 리팩토링을 통해 `MyLibrary` 관련 컴포넌트들은 **Container/Presentational 패턴**에 가까운 구조를 갖게 되었으며, 이는 코드의 재사용성과 테스트 용이성을 높이는 기반이 됩니다.

(참고) fix(types): MyLibrary에서 Set 타입 추론 오류 수정

본문:
MyLibrary.tsx 컴포넌트 내에서 Set 객체를 새로 생성하거나 복제할 때 타입이 Set<unknown>으로 추론되는 문제를 해결했습니다.

useState, new Set(), new Set(iterable) 구문에서 제네릭 타입 <string>을 명시적으로 선언하여, activeTags 상태 및 관련 변수들이 항상 Set<string> 타입을 유지하도록 수정했습니다.

주요 변경 사항:

    handleTagClick, handleClearAllTags, resetAllLibraryStates 함수 내에서 new Set<string>()으로 타입 명시

    useState<ViewType> 선언 시 ViewType을 types.ts에서 import 하도록 수정

    리팩토링 후 남은 불필요한 주석 코드(LibraryTag 컴포넌트) 제거

이를 통해 filterLibraryByTags 함수 호출 시 발생하던 타입 에러를 해결하고 코드의 타입 안정성을 강화했습니다.


aed0c1a
ahnbu
Mon Oct 27 14:32:29 2025 +0900
fix(api): Cloudflare Worker의 키워드 검색 로직 오류 수정   - 경기도교육청 전자책 검색 결과 처리 시, 존재하지 않는 'availability' 키 대신 올바른 'book_list' 키를 참조하도록 수정하여 검색 결과 누락 문제 해결


8fc5931
ahnbu
Sun Oct 26 16:26:10 2025 +0900
fix(api): 🔧 APITestContent의 API 호출 시그니처 불일치 수정
`unifiedLibrary.service`의 `fetchBookAvailability` 함수 시그니처가 `author` 인수를 필수로 받도록 변경됨에 따라, `APITestContent` 컴포넌트에서 해당 함수를 호출할 때 발생하던 타입스크립트 오류를 수정했습니다.

### 주요 변경 사항

- **`author` 상태 추가**:
  - `APITestContent` 컴포넌트에 `author`와 `setAuthor` 상태를 추가하여 저자 정보를 관리하도록 변경했습니다.

- **API 호출 인수 추가**:
  - `runApiTest` 함수가 `author` 인수를 받도록 시그니처를 업데이트했습니다.
  - 책 검색 후 자동 테스트 실행(`handleApiSelectBook`) 및 수동 테스트 실행(`handleSubmit`) 시 `fetchBookAvailability` 함수에 `author` 인수가 올바르게 전달되도록 수정했습니다.

- **상태 업데이트 로직 개선**:
  - 검색 모달에서 책을 선택하면(`handleApiSelectBook`), `isbn`과 `title`뿐만 아니라 `author` 상태도 함께 업데이트되도록 로직을 개선했습니다.

이번 수정으로 API 테스트 페이지의 기능이 최신 서비스 로직과 일치하게 되어 정상적으로 동작합니다.


afc6431
ahnbu
Sun Oct 26 16:15:31 2025 +0900
refactor : 전반적인 주석 제거


9b2e6c4
ahnbu
Sun Oct 26 16:04:10 2025 +0900
fxi: 좋아요 필터링 버그 수정
좋아요 필터링이 초기 50건에 대해서만 동작하는 버그를 수정했다. 이를 위해 서버 기반의 '좋아요 필터링' 기능을 추가하고, 필터링된 뷰에서 상태 변경이 즉시 UI에 반영되지 않던 버그를 해결했습니다.

### 주요 변경 사항

#### 1. 서버 기반 '좋아요' 필터링 기능 구현 (`useBookStore.ts`)
- **`filterLibraryByFavorites` 액션 추가**:
  - Supabase DB에 `isFavorite: true`인 모든 책을 직접 요청하는 기능을 구현했습니다.
  - 초기 로딩된 50권이 아닌 전체 서재를 대상으로 필터링하여 정확성을 확보했습니다.
  - JSONB 타입에 최적화된 `.contains()` 연산자를 사용하여, `isFavorite` 키가 없는 레코드로 인한 조회 실패 문제를 원천적으로 방지합니다.
- **`libraryFavoritesFilterResults` 상태 추가**:
  - '좋아요' 필터링 결과를 저장할 `libraryFavoritesFilterResults` 상태와 관련 로딩 상태(`isFilteringByFavorites`)를 추가했습니다.
- **`clearLibraryFavoritesFilter` 액션 추가**:
  - 필터 해제 시 관련 상태를 초기화하는 기능을 추가했습니다.

#### 2. '좋아요' 필터 UI 연동 (`MyLibrary.tsx`)
- **버튼 핸들러 수정**:
  - '좋아요' 버튼 클릭 시, 로컬 상태(`showFavoritesOnly`) 변경과 함께 `filterLibraryByFavorites` 스토어 액션을 호출하도록 `handleToggleFavoritesFilter` 함수를 구현했습니다.
- **데이터 소스 분기 처리**:
  - `sortedAndFilteredLibraryBooks`의 `useMemo` 로직을 수정하여, `showFavoritesOnly`가 true일 때 `libraryFavoritesFilterResults` 배열을 데이터 소스로 사용하도록 변경했습니다.
- **로딩 UI 개선**:
  - '좋아요' 필터링이 진행되는 동안 사용자에게 스피너와 함께 "좋아하는 책을 찾는 중입니다..." 메시지를 표시하도록 UI를 개선했습니다.

#### 3. UI 상태 동기화 버그 수정 (`useBookStore.ts`)
- **문제점**:
  - '좋아요' 필터링된 뷰에서 하트 아이콘 클릭 시, DB 데이터는 변경되지만 필터링된 목록(`libraryFavoritesFilterResults`)이 업데이트되지 않아 UI가 갱신되지 않았습니다.
- **해결**:
  - 핵심 데이터 업데이트 함수인 `updateBookInStoreAndDB`가 `myLibraryBooks` 등 기존 3개 배열뿐만 아니라 `libraryFavoritesFilterResults` 배열도 동시에 업데이트하도록 수정했습니다.
  - '좋아요'가 해제된 책은 `.filter()`를 통해 필터링된 목록에서 즉시 제거하여, 사용자의 액션이 UI에 실시간으로 반영되도록 개선했습니다.


25be2ec
ahnbu
Sat Oct 25 19:39:43 2025 +0900
fix(tags): 상세 모달의 태그 정렬 불일치 문제 해결 - 선택된 태그 부분
`MyLibraryBookDetailModal`의 "사용 가능한 태그" 목록이 다른 UI 영역과 달리 색상에 따라 정렬되지 않는 마지막 UI 불일치 문제를 수정했습니다.

- **원인:** 해당 목록을 렌더링하는 로직에 정렬(sort) 단계가 누락되어 있었습니다.
- **해결:** 렌더링 파이프라인에 `1.색상 우선순위`, `2.이름 가나다순`을 기준으로 하는 정렬 로직을 추가하여, 이제 애플리케이션의 모든 태그 표시 영역이 동일한 정렬 규칙을 따르도록 일관성을 확보했습니다.

이 커밋으로 최근 진행된 태그 시스템 개선 작업이 모두 완료되었습니다.


231ced7
ahnbu
Sat Oct 25 19:36:30 2025 +0900
fix(tags): 상세 모달의 태그 정렬 불일치 문제 해결
`MyLibraryBookDetailModal`의 "사용 가능한 태그" 목록이 다른 UI 영역과 달리 색상에 따라 정렬되지 않는 마지막 UI 불일치 문제를 수정했습니다.

- **원인:** 해당 목록을 렌더링하는 로직에 정렬(sort) 단계가 누락되어 있었습니다.
- **해결:** 렌더링 파이프라인에 `1.색상 우선순위`, `2.이름 가나다순`을 기준으로 하는 정렬 로직을 추가하여, 이제 애플리케이션의 모든 태그 표시 영역이 동일한 정렬 규칙을 따르도록 일관성을 확보했습니다.

이 커밋으로 최근 진행된 태그 시스템 개선 작업이 모두 완료되었습니다.


691ec63
ahnbu
Sat Oct 25 19:29:59 2025 +0900
fix(name) : e교육 db 조회명칭 book.ebookInfo -> book.GyeonggiEduEbookInfo로 변경


af4fe66
ahnbu
Sat Oct 25 19:27:04 2025 +0900
docs: 프로젝트 문서 대규모 업데이트 및 최신화
개발 속도에 맞춰 한동안 업데이트되지 않았던 핵심 문서(README, DEVELOPMENT, CHANGELOG)를 현재 구현 내용과 완벽하게 동기화했습니다.

이번 업데이트는 신규 참여자의 온보딩 비용을 줄이고, 프로젝트의 기술적 성과와 발전 과정을 명확하게 기록하여 유지보수성을 높이는 것을 목표로 합니다.

### 1. `CHANGELOG.md` 업데이트
- **이력 복원**: `v2.0.0` 이후 누락되었던 19개 이상의 주요 커밋 히스토리를 분석하여 변경 내역을 모두 복원하고 `v2.1.0` 버전을 추가했습니다.
- **체계화**: 각 변경 사항을 `Fix`, `Feature`, `Refactor` 등으로 분류하고, 커밋 해시를 첨부하여 추적 용이성을 확보했습니다.

### 2. `README.md` (사용자 중심 문서) 전면 개정
- **기능 최신화**: '일괄 재고 갱신' 옵션 확장, '전자책' 검색 등 최근 추가된 모든 기능을 "주요 기능" 섹션에 반영했습니다.
- **성과 요약**: "최신 기술적 개선사항" 섹션을 재구성하여, 데이터 유실 방지, 상태 동기화 버그 해결, API 응답 캐싱 등 주목할 만한 기술적 성과를 상단에 배치하고 요약했습니다.

### 3. `DEVELOPMENT.md` (개발자 중심 문서) 정밀 동기화
- **API 명세 수정**: Cloudflare Workers API 명세에서 실제 코드 변경 사항(예: `author` 파라미터 제거)을 정확히 반영했습니다.
- **데이터 흐름 재설명**: `createBookDataFromApis`의 역할, 데이터 복원 로직 등 현재의 데이터 처리 파이프라인을 Mermaid 다이어그램과 함께 명확하게 재정의했습니다.
- **트러블슈팅 가이드 추가**: 최근 해결한 '"조회중..." 무한 반복 버그'의 원인과 해결책을 추가하여 개발자들의 디버깅을 돕도록 했습니다.
